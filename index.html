<!DOCTYPE html>
<meta charset="utf-8">
<head>
    <link href="./materialize/css/nouislider.css" rel="stylesheet">
</head>

<style> /* set the CSS */

.line {
  fill: none;
  stroke: steelblue;
  stroke-width: 2px;
}

.hidden {
    display: none;
}

div.tooltip {
    color: #222;
    background-color: #fff;
    padding: .5em;
    text-shadow: #f5f5f5 0 1px 0;
    border-radius: 2px;
    opacity: 0.9;
    position: absolute;
}

</style>
<body>


<!-- load the d3.js library -->    	
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="./materialize/js/nouislider.js"></script>

<div>
    </br>
    <p>Months (1-12)</p>
    <div id="slider_months"></div>
    </br>
    <p>Days (1-31)</p>
    <div id="slider_day_months"></div>
</div>

<script>
var COMPANY_TO_FOLLOW = undefined;
//pour le hover
var tooltip = d3.select('body').append('div')
.attr('class', 'hidden tooltip');

// set the dimensions and margins of the graph
var margin = {top: 50, right: 50, bottom: 50, left: 100},
    width = 1600 - margin.left - margin.right,
    height = 800 - margin.top - margin.bottom;

var color = [];
var xScale = 0, yScale = 0, dx = 0, dy = 0, xAxis = 0, yAxis = 0;

var names = [];
var color = d3.scaleLinear()
.domain([0,names.length])
.range(["rgb(255, 100, 0)", "rgb(0, 100, 255)"])
.interpolate(d3.interpolateHcl);

//,Year,Month,DayofMonth,DayOfWeek,DepTime,CRSDepTime,ArrTime,CRSArrTime,UniqueCarrier,FlightNum,TailNum,ActualElapsedTime,CRSElapsedTime,AirTime,ArrDelay,DepDelay,Origin,Dest,Distance,TaxiIn,TaxiOut,Cancelled,CancellationCode,Diverted,CarrierDelay,WeatherDelay,NASDelay,SecurityDelay,LateAircraftDelay

// append the svg obgect to the body of the page
// appends a 'group' element to 'svg'
// moves the 'group' element to the top left margin
var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .call(d3.zoom().on("zoom", zoomFunction))
    .append("g")
    .attr("transform",
          "translate(" + margin.left + "," + margin.top + ")");

var bubble_width = width * 0.70;
var bubble_height = height;
var pie_width = width * 0.27;
var pie_height = height;

var oldPieChart = undefined;
var oldPieData = undefined;
var radius = Math.min(pie_width, pie_height) / 2;
var radiusScale = d3.scaleSqrt()
			.range([0, radius])
			.domain([0, 110]);

var toProcess = [];
var json_companys = [];

d3.csv("data_22.csv", function(data) {
    //PARAMETRE A MODIFIER PAR SLIDER
    var y_min = 2008, y_max = 2008, m_min = 1, m_max = 12, dm_min = 0, dm_max = 31;

    // When the slider value changes, update the input and span
    sliderMonth.noUiSlider.on('update', function( values, handle ) {
        m_min = parseInt(values[0]);
        m_max = parseInt(values[1]);
        parseData(data, y_min, y_max, m_min, m_max, dm_min, dm_max);
        json_companys.sort(sortByDelay);
        getNewAxis();
        updateAxis();
        if(COMPANY_TO_FOLLOW != undefined){
            var pie_data = buildData(COMPANY_TO_FOLLOW);
            updatePie(COMPANY_TO_FOLLOW, pie_data);
        }
        updateBubble(json_companys);
    });
    sliderDayMonth.noUiSlider.on('update', function( values, handle ) {
        dm_min = parseInt(values[0]);
        dm_max = parseInt(values[1]);
        parseData(data, y_min, y_max, m_min, m_max, dm_min, dm_max);
        json_companys.sort(sortByDelay);
        getNewAxis();
        updateAxis();
        if(COMPANY_TO_FOLLOW != undefined){
            var pie_data = buildData(COMPANY_TO_FOLLOW);
            updatePie(COMPANY_TO_FOLLOW, pie_data);
        }
        updateBubble(json_companys);
    });

    parseData(data, y_min, y_max, m_min, m_max, dm_min, dm_max);

    getNewAxis();

    // Add the y Axis
    dy = svg.append("g")
        .attr("class", "y axis")        
        .call(yAxis)
        .select(".domain");

    // Add the x Axis
    dx = svg.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis)
        .select(".domain");

    for(var c in companys){
        names.push(c);
    }

    color = d3.scaleLinear()
    .domain([0,25])
    .range(["rgb(255, 100, 0)", "rgb(0, 100, 255)"])
    .interpolate(d3.interpolateHcl);

    var max = d3.max(json_companys, function(d) { return parseInt(d.totalDelay); }) + 1;
    var min = d3.min(json_companys, function(d) { return parseInt(d.totalDelay); });
    
    draw();
});

var lastTk = 1, lastTx = 0, lastTy = 1;
function zoomFunction(){
    //Limiter le zoom
    var t = d3.event.transform;

    var max_zoom = 5;
    var min_zoom = 0.6;
    if(t.k > max_zoom){
        t.k = lastTk;
        t.x = lastTx;
        t.y = lastTy;
    }
    if(t.k < min_zoom){
        t.k = lastTk;
        t.x = lastTx;
        t.y = lastTy;
    }

    // create new scale ojects based on event
    var new_xScale = d3.event.transform.rescaleX(xScale)
    var new_yScale = d3.event.transform.rescaleY(yScale)

    // update circle
    svg.attr("transform", d3.event.transform);

    if(lastTk != t.k){
        //draw(t);
        updateBubble(json_companys, t);
    }
    else{
        updateTooltip(t);
    }

    lastTk = t.k;
    lastTx = t.x;
    lastTy = t.y;
};

function draw(t = undefined){
    var max = d3.max(json_companys, function(d) { return parseInt(d.totalDelay); }) + 1;
    var min = d3.min(json_companys, function(d) { return parseInt(d.totalDelay); });

    //svg.selectAll("circle").remove();
    //Dessine les cercles
    svg.selectAll(".companys")
        .data(json_companys)
        .enter()
        .append("circle")
        .attr("cx", function(d){ return xScale(d.Distance); })
        .attr("cy", function(d){ return yScale(d.ActualElapsedTime); })
        .attr("r", function(d){
                var div = lastTk;
                if(t != undefined)
                    div = t.k;
                var r = rescaler(parseInt(d.totalDelay), min, max, 10 / div, 20 / div);
                return r; 
            })
        .attr("fill", function(d, i){
            return color(i);
        })
        .on('mousemove', function(d) {
            d3.select(this).style("cursor", "pointer");
            var mouse = d3.mouse(svg.node()).map(function(d) {
                return parseInt(d);
            });
            
            tooltip.classed('hidden', false)
                .attr('style', 'left:' + (mouse[0]) +
                    'px; top:' + (mouse[1]) + 'px', 'position: absolute;')
                .html(function(i){
                    return d.name + ", retard moyen : " + parseInt(d.totalDelay) + " mn";
                });
            })
        .on('mouseout', function() {
            d3.select(this).style("cursor", "default"); 
            tooltip.classed('hidden', true);
        })
        .on("click", function(d){
            if(COMPANY_TO_FOLLOW == d.name){
                COMPANY_TO_FOLLOW = undefined;
                svg.selectAll(".pie_chart").remove();
            }
            else{
                COMPANY_TO_FOLLOW = d.name;
                var pie_data = buildData(d.name);
                drawPie(d.name, pie_data);
            }
            updateBubble(json_companys);            
        });
}

function updateBubble(json_companys, t = undefined){
    var max = parseInt(d3.max(json_companys, function(d) { return parseInt(d.totalDelay); }) + 1);
    var min = parseInt(d3.min(json_companys, function(d) { return parseInt(d.totalDelay); }));

    var svg = d3.select("svg");
    var animationDuration = 400;
    var tr = d3.transition().duration(animationDuration);
    
    //Dessine les cercles
    svg.selectAll("circle")
        .transition(tr)
        .attr("cx", function(d){ return xScale(d.Distance); })
        .attr("cy", function(d){ return yScale(d.ActualElapsedTime); })
        .attr("r", function(d){
            if(isNaN(min) || isNaN(max)) 
                return 0;
            var found = false;
            for(var currd in json_companys){
                if(d.name == json_companys[currd].name){
                    found = true;
                }
            }
            if(!found) 
                return 0;
            var div = lastTk;
            if(t != undefined)
                div = t.k;
            var r = rescaler(parseInt(d.totalDelay), min, max, 10 / div, 20 / div);
            return r; 
        })
        .attr("fill", function(d, i){
            return color(i);
        })        
        .attr("stroke", "black")
        .attr("stroke-width", function(d){
            var div = lastTk;
            if(t != undefined)
                div = t.k;
            if(d.name == COMPANY_TO_FOLLOW){
                return 8 / div;
            }
            return 1 / div;
    });
}

function updateTooltip(t){
    svg.selectAll("circle")
        .on('mousemove', function(d) {
            d3.select(this).style("cursor", "pointer");
            var mouse = d3.mouse(svg.node()).map(function(d) {
                return parseInt(d);
            });
            var minus = lastTy;
            
            tooltip.classed('hidden', false)
                .attr('style', 'left:' + (mouse[0] + t.x / t.k) +
                    'px; top:' + (mouse[1] + t.y / 2) + 'px', 'position: absolute;')
                .html(function(i){
                    return d.name + ", retard moyen : " + parseInt(d.totalDelay) + " mn";
                });
            })
        .on('mouseout', function() {
            d3.select(this).style("cursor", "default"); 
            tooltip.classed('hidden', true);
        });
}

function parseData(data, y_min, y_max, m_min, m_max, dm_min, dm_max){
    companys = {};
    json_companys = [];
    //Agregation de données par companies
    for(var d = 0; d < data.length; d += 1){
        if(data[d].Month > m_max)
            break;
        if(data[d].Month >= m_min){
            if(data[d].Year >= y_min && data[d].Year <= y_max && data[d].Month >= m_min && data[d].Month <= m_max 
            && data[d].DayofMonth >= dm_min && data[d].DayofMonth <= dm_max){
                if(companys[data[d].UniqueCarrier] == undefined){
                    if(data[d].Distance != "" && data[d].ActualElapsedTime != ""){
                        //Sécu pour ne pas prendre en compte les lignes où les données nous manque
                        if(data[d].ArrDelay == "")
                            data[d].ArrDelay = 0;
                        if(data[d].CarrierDelay == "")
                            data[d].CarrierDelay = 0;
                        if(data[d].WeatherDelay == "")
                            data[d].WeatherDelay = 0;
                        if(data[d].NASDelay == "")
                            data[d].NASDelay = 0;
                        if(data[d].SecurityDelay == "")
                            data[d].SecurityDelay = 0;
                        if(data[d].LateAircraftDelay == "")
                            data[d].LateAircraftDelay = 0;
                        if(data[d].Cancelled == "")
                            data[d].Cancelled = 0;
                        if(data[d].Diverted == "")
                            data[d].Diverted = 0;

                        companys[data[d].UniqueCarrier] = {
                            "Distance": parseInt(data[d].Distance), 
                            "ActualElapsedTime": parseInt(data[d].ActualElapsedTime), 
                            "totalDelay": parseInt(data[d].ArrDelay), 
                            "CarrierDelay": parseInt(data[d].CarrierDelay),
                            "WeatherDelay": parseInt(data[d].WeatherDelay),
                            "NASDelay": parseInt(data[d].NASDelay),
                            "SecurityDelay": parseInt(data[d].SecurityDelay),
                            "LateAircraftDelay": parseInt(data[d].LateAircraftDelay),
                            "Cancelled": parseInt(data[d].Cancelled), 
                            "Diverted": parseInt(data[d].Cancelled),
                            "cpt": 1};
                    }
                }
                else{
                    //Sécu pour ne pas prendre en compte les lignes où les données nous manque
                    if(data[d].Distance != "" && data[d].ActualElapsedTime != ""){
                        //Rempli les données à 0 la où elles manquent dans le dataset
                        if(data[d].ArrDelay == "")
                            data[d].ArrDelay = 0;
                        if(data[d].CarrierDelay == "")
                            data[d].CarrierDelay = 0;
                        if(data[d].WeatherDelay == "")
                            data[d].WeatherDelay = 0;
                        if(data[d].NASDelay == "")
                            data[d].NASDelay = 0;
                        if(data[d].SecurityDelay == "")
                            data[d].SecurityDelay = 0;
                        if(data[d].LateAircraftDelay == "")
                            data[d].LateAircraftDelay = 0;
                        if(data[d].Cancelled == "")
                            data[d].Cancelled = 0;
                        if(data[d].Diverted == "")
                            data[d].Diverted = 0;                            
                        companys[data[d].UniqueCarrier].Distance += parseInt(data[d].Distance);
                        companys[data[d].UniqueCarrier].ActualElapsedTime += parseInt(data[d].ActualElapsedTime);
                        companys[data[d].UniqueCarrier].totalDelay += parseInt(data[d].ArrDelay);
                        companys[data[d].UniqueCarrier].CarrierDelay += parseInt(data[d].CarrierDelay);
                        companys[data[d].UniqueCarrier].WeatherDelay += parseInt(data[d].WeatherDelay);
                        companys[data[d].UniqueCarrier].NASDelay += parseInt(data[d].NASDelay);
                        companys[data[d].UniqueCarrier].SecurityDelay += parseInt(data[d].SecurityDelay);
                        companys[data[d].UniqueCarrier].LateAircraftDelay += parseInt(data[d].LateAircraftDelay);
                        companys[data[d].UniqueCarrier].Cancelled += parseInt(data[d].Cancelled);
                        companys[data[d].UniqueCarrier].Diverted += parseInt(data[d].Cancelled);
                        companys[data[d].UniqueCarrier].cpt += 1;
                    }
                }
            }
        }
        else{
            //d += 1;
        }
    }

    //Moyennes
    for(var c in companys){
        companys[c].totalDelay = parseInt(companys[c].totalDelay) / companys[c].cpt;
        companys[c].Distance = parseInt(companys[c].Distance) / companys[c].cpt;
        companys[c].ActualElapsedTime = parseInt(companys[c].ActualElapsedTime) / companys[c].cpt;
        companys[c].CarrierDelay = parseInt(companys[c].CarrierDelay) / companys[c].cpt;
        companys[c].WeatherDelay = parseInt(companys[c].WeatherDelay) / companys[c].cpt;
        companys[c].NASDelay = parseInt(companys[c].NASDelay) / companys[c].cpt;
        companys[c].SecurityDelay = parseInt(companys[c].SecurityDelay) / companys[c].cpt;
        companys[c].LateAircraftDelay = parseInt(companys[c].LateAircraftDelay) / companys[c].cpt;
        companys[c].Cancelled = parseInt(companys[c].Cancelled) / companys[c].cpt;
        companys[c].Diverted = parseInt(companys[c].Diverted) / companys[c].cpt;
    }

    for(var c in companys){
        json_companys.push({
            "name": c, 
            "Distance": companys[c].Distance, 
            "ActualElapsedTime": companys[c].ActualElapsedTime,
            "CarrierDelay": companys[c].CarrierDelay,
            "WeatherDelay": companys[c].WeatherDelay,
            "NASDelay": companys[c].NASDelay,
            "SecurityDelay": companys[c].SecurityDelay,
            "LateAircraftDelay": companys[c].LateAircraftDelay,
            "Cancelled": companys[c].Cancelled,
            "Diverted": companys[c].Diverted,
            "totalDelay": companys[c].totalDelay});
    }
}

function getNewAxis(){
    //get max pour les axes
    var max_dist = 0;
    var max_elapsed = 0;
    for(var c in companys){
        if(parseInt(companys[c].Distance) > max_dist){
            max_dist = parseInt(companys[c].Distance);
        }
        if(parseInt(companys[c].ActualElapsedTime) > max_elapsed){
            max_elapsed = parseInt(companys[c].ActualElapsedTime);
        }
    }
    
    //Trie du tableau pour afficher les grands cercles en premier et ne pas cacher les plus petits
    json_companys.sort(sortByDelay);
    
    xScale = d3.scaleLinear().domain([0, max_dist]).range([0, bubble_width]);
    yScale = d3.scaleLinear().domain([0, max_elapsed]).range([bubble_height, 0]);

    xAxis = d3.axisBottom(xScale);
    yAxis = d3.axisLeft(yScale);
}

function updateAxis(){
    var t = d3.transition()
        .duration(200)
    
    svg.select(".x")
        .transition(t)
        .call(xAxis)
    
    svg.select(".y")
        .transition(t)
        .call(yAxis)
}

function rescaler(val, min_in, max_in, min_out, max_out){
    if(val > max_in)
        max_in = val;
    if(val < min_in)
        min_in = val;
    
    if( min_in == max_in)
        return val;
        
    return (max_out - min_out) * (val - min_in + 0.0001) /  (max_in - min_in + 0.0001) + min_out ;
}

//Trie par retard (decroissant)
function sortByDelay(a, b){
  return (a.totalDelay > b.totalDelay) ? 0 : 1;
}

function buildData(companyName){
    var pie_data = [];
    for(var i in json_companys){
        if(json_companys[i].name == companyName){
            pie_data = [
                {"name": "CarrierDelay", "number": json_companys[i].CarrierDelay},
                {"name": "WeatherDelay", "number": json_companys[i].WeatherDelay},
                {"name": "NASDelay", "number": json_companys[i].NASDelay},
                {"name": "SecurityDelay", "number": json_companys[i].SecurityDelay},
                {"name": "LateAircraftDelay", "number": json_companys[i].LateAircraftDelay}
            ];
            break;
        }
    }
    return pie_data;
}

var sliderMonth = document.getElementById('slider_months');
    noUiSlider.create(sliderMonth, {
    start: [1, 12],
    connect: true,
    step: 1,
    orientation: 'horizontal', // 'horizontal' or 'vertical'
    tooltips: [ wNumb({ decimals: 0 }), wNumb({ decimals: 0 }) ],
    range: {
        'min': 1,
        'max': 12
    },
    format: wNumb({
        decimals: 0
    })
});

var sliderDayMonth = document.getElementById('slider_day_months');
    noUiSlider.create(sliderDayMonth, {
    start: [1, 31],
    connect: true,
    step: 1,
    orientation: 'horizontal',
    tooltips: [ wNumb({ decimals: 0 }), wNumb({ decimals: 0 }) ],
    range: {
        'min': 1,
        'max': 31
    },
    format: wNumb({
        decimals: 0
    })
});

function clean_pie_data(pie_data){
    //Nettoyage de pie_data
    for(var pd in pie_data){
        for(var pd in pie_data){
            if(parseInt(pie_data[pd].number) == 0){
                pie_data.splice(pd, 1);
                break;
            }
        }
    }
    return pie_data;
}

function drawPie(name, pie_data){
    //pie_data = clean_pie_data(pie_data);

    //Préparation du pie chart
    var svg = d3.select("svg");
    var animationDuration = 400;
    var t = d3.transition().duration(animationDuration);

    //Suppression de l'ancien s'il y en a un
    svg.selectAll(".pie_chart").remove();

    var g = svg.append("g")
    .attr("transform", "translate(" + parseInt(bubble_width + pie_width) + "," + pie_height / 2 + ")")
    .attr("class", "pie_chart");

    var color = d3.scaleOrdinal(["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"]);

    var pie = d3.pie()
        .sort(null)
        .value(function(d) { return d.number; });

    var path = d3.arc()
        .outerRadius(radius - 10)
        .innerRadius(0);

    var label = d3.arc()
        .outerRadius(radius - 40)
        .innerRadius(radius - 40);

    var pie_arc = g.selectAll(".arc")
        .data(pie(pie_data))
        .enter()
        .append("g")
        .attr("class", "arc");

    pie_arc.append("path")
        .attr("d", path)
        .attr("fill", function(d) { return color(d.data.name); });

    pie_arc.append("text")
        .transition(t)
        .attr("transform", function(d) { return "translate(" + label.centroid(d) + ")"; })
        .attr("dy", "0.35em")
        .text(function(d) { return d.data.name; });
    oldPieData = pie_data;
    oldPieChart = pie;
}

function updatePie(name, pie_data){
    //pie_data = clean_pie_data(pie_data);
    if(pie_data.length > 0){
        transition(pie_data);
    }
    else{
        svg.selectAll(".pie_chart").remove();
    }
    oldPieData = pie_data;
}

function arcs(data) {
    console.log(oldPieData);
    console.log(data);
    var pie = d3.pie()
    .sort(null);

    var n = Object.keys(data).length;
        console.log("test 0");
    var arcs0 = pie(getNumber(oldPieData)),
        arcs1 = pie(getNumber(data));
        console.log("test 0.5");

    var sum = 0;
    for(var x in oldPieData){
        sum += parseInt(oldPieData[x].number);
    }

    var sum2 = 0;
    for(var x in data){
        sum2 += parseInt(data[x].number);
    }

    var i = -1,
    outerRad0 = radiusScale(sum),
    outerRad1 = radiusScale(sum2);
    
    console.log("hi", outerRad0, outerRad1) ;                                                               // @debug
    console.log("n : " + n) ;                                                               // @debug
    
    while (++i < n) {
        arc = arcs0[i];
        arc.outerRadius = outerRad0;
        arc.startAngle = arc.startAngle + 0.1;
        arc.endAngle = arc.endAngle + 0.1;
        arc.next = arcs1[i];
        arc.next.outerRadius = outerRad1; 
    }
    oldPieChart = arcs1;
    return arcs0;
}

function transition(to) {
    var path = d3.selectAll(".arc > path")
        .data(arcs(to));
    
    // Wedges then update their values, changing size.
    var t2 = path.transition()
                .duration(1000)
            .attrTween("d", tweenArc(function(d, i) {
            console.log(d)
            return {
                startAngle: d.next.startAngle,
                endAngle: d.next.endAngle,
                outerRadius: d.next.outerRadius
            };
            }));
}
  
function tweenArc(b) {
    var arc = d3.arc().innerRadius(0);
    return function(a, i) {
        var d = b.call(this, a, i), i = d3.interpolate(a, d);
        for (var k in d) a[k] = d[k]; // update data
        return function(t) { return arc(i(t)); };
    };
}



function getNumber(matrix){
    var column = [];
    for(var i in matrix){
        column.push(matrix[i].number);
    }
    return column;
}
</script>
</body>
